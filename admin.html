<script type="module">
import { GITHUB_USERNAME, REPO_NAME, FILE_PATH, BRANCH, TOKEN } from './config.js';

async function updateDataJson(newData) {
    // Get the current file SHA (needed to update)
    const res = await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/${FILE_PATH}?ref=${BRANCH}`, {
        headers: { Authorization: `token ${TOKEN}` }
    });
    const fileData = await res.json();
    const sha = fileData.sha;

    // Encode the new data
    const content = btoa(JSON.stringify(newData, null, 2));

    // Push the update
    const updateRes = await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/${FILE_PATH}`, {
        method: "PUT",
        headers: {
            "Authorization": `token ${TOKEN}`,
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            message: "Update PFL live scores",
            content: content,
            sha: sha,
            branch: BRANCH
        })
    });

    const result = await updateRes.json();
    console.log("Update result:", result);
}
</script>
<div class="wrap">

  <div class="card">
    <h3 style="margin:0;color:var(--gold)">Repository / Data Settings</h3>
    <label>GitHub Raw data URL</label>
    <input id="rawUrl" value="https://raw.githubusercontent.com/rowlandmayowa527-ai/pfl-livescore-center/main/data.json">
    <div class="small">Keep this pointing to your <code>data.json</code> raw path. The public index fetches from here.</div>
    <label style="margin-top:8px">Repo details (for auto-publish)</label>
    <div class="row">
      <input id="ghOwner" class="col" placeholder="GitHub owner (username)" value="rowlandmayowa527-ai">
      <input id="ghRepo" class="col" placeholder="Repo name" value="pfl-livescore-center">
    </div>
    <div class="row">
      <input id="ghBranch" class="col" placeholder="Branch" value="main">
      <input id="filePath" class="col" placeholder="File path" value="data.json">
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0;color:var(--gold)">Quick: Round 1 Fixtures</h3>
    <div class="small">You can edit fixtures below. Default Round 1 is preloaded.</div>
    <label>Fixtures (one per line: date,time,home,away,venue)</label>
    <textarea id="fixturesText" rows="4"></textarea>
    <div style="margin-top:8px;"><button class="btnGold" id="btnLoadFixtures">Load into editor</button></div>
  </div>

  <div class="card">
    <h3 style="margin:0;color:var(--gold)">Live Match Editor</h3>
    <div class="small">Choose a fixture then Set Live to publish it to <code>data.json</code>.</div>

    <label>Select fixture</label>
    <select id="selectFixture"></select>

    <div class="row">
      <div class="col">
        <label>Home score</label>
        <input id="homeScore" type="number" min="0" value="0">
      </div>
      <div class="col">
        <label>Away score</label>
        <input id="awayScore" type="number" min="0" value="0">
      </div>
    </div>

    <label>Substitutions / Notes (one per line)</label>
    <textarea id="liveSubs" rows="3"></textarea>

    <label>Home ratings (Player-Score, comma separated)</label>
    <input id="homeRatings" type="text">
    <label>Away ratings</label>
    <input id="awayRatings" type="text">

    <div style="margin-top:10px;" class="row">
      <button class="btnGold" id="btnSetLive">Set Live</button>
      <button class="btnGhost" id="btnUpdateLive">Update Live</button>
      <button class="btnGhost" id="btnEndAndArchive">End & Archive</button>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0;color:var(--gold)">Data JSON (preview / export / publish)</h3>
    <div class="small">Edit locally, then Export or Publish to GitHub (optional token required).</div>
    <pre id="jsonPreview">Loading data…</pre>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <button class="btnGold" id="btnExport">Export JSON (copy)</button>
      <button class="btnGhost" id="btnImport">Import JSON (paste)</button>
      <button class="btnGhost" id="btnPublish">Publish to GitHub (optional)</button>
    </div>
    <div style="margin-top:8px;" class="small">If you publish, you'll be asked for a GitHub token (use a token you create & keep private). You can also update data.json manually in GitHub.</div>
  </div>

  <div class="card">
    <h3 style="margin:0;color:var(--gold)">Archive & Helpers</h3>
    <div class="small">Archive shows saved matches and allows lightweight editing.</div>
    <div id="archivePreview" class="small">No archive loaded</div>
  </div>

</div>

<script>
/* Admin logic (no server required). Works with data.json in your repo. */
/* Local edit model */
let model = null;
const DEFAULT_RAW = document.getElementById('rawUrl').value;

/* helpers */
function b64Encode(str){ return btoa(unescape(encodeURIComponent(str))); }
function b64Decode(str){ return decodeURIComponent(escape(atob(str))); }

/* load remote data.json preview */
async function loadRemote(){
  const url = document.getElementById('rawUrl').value.trim() || DEFAULT_RAW;
  try{
    const r = await fetch(url + '?cachebust=' + Date.now());
    if(!r.ok) throw new Error('no remote data');
    model = await r.json();
  }catch(e){
    // fall back to default if remote missing
    if(!model) model = { meta:{competition:'Pinnacle Football League', organiser:'Arcane Override Games', updatedAt:new Date().toISOString()}, live:null, fixtures:[], archive:[], predictions:[], comments:[], players:{} };
  }
  refreshUI();
}

/* refresh UI from model */
function refreshUI(){
  document.getElementById('jsonPreview').innerText = JSON.stringify(model, null, 2);
  // populate fixtures select and fixturesText
  const sel = document.getElementById('selectFixture');
  sel.innerHTML = '<option value="">-- pick --</option>';
  document.getElementById('fixturesText').value = (model.fixtures||[]).map(f => `${f.date},${f.time},${f.home},${f.away},${f.venue}`).join('\\n');
  (model.fixtures||[]).forEach((f,i)=> sel.innerHTML += `<option value="${i}">${f.date} ${f.time} • ${f.home} vs ${f.away}</option>`);
  // archive preview
  document.getElementById('archivePreview').innerText = (model.archive||[]).slice().reverse().map(m => `${m.homeTeam} ${m.homeScore}:${m.awayScore} ${m.awayTeam} (${m.timestamp})`).slice(0,10).join('\\n') || 'No archived matches';
}

/* load default remote on start */
loadRemote();

/* fixtures load button */
document.getElementById('btnLoadFixtures').addEventListener('click', ()=>{
  const lines = document.getElementById('fixturesText').value.trim().split('\\n').map(l=>l.trim()).filter(Boolean);
  const arr = lines.map(line => {
    const parts = line.split(',').map(s=>s.trim());
    return { date: parts[0]||'', time: parts[1]||'', home: parts[2]||'', away: parts[3]||'', venue: parts[4]||'' };
  });
  model.fixtures = arr;
  model.meta.updatedAt = new Date().toISOString();
  refreshUI();
});

/* set live */
document.getElementById('btnSetLive').addEventListener('click', ()=>{
  const idx = document.getElementById('selectFixture').value;
  if(idx === '') return alert('Pick a fixture');
  const f = model.fixtures[idx];
  if(!f) return alert('Missing fixture');
  model.live = {
    homeTeam: f.home,
    awayTeam: f.away,
    homeScore: Number(document.getElementById('homeScore').value||0),
    awayScore: Number(document.getElementById('awayScore').value||0),
    subs: (document.getElementById('liveSubs').value||'').split('\\n').filter(Boolean),
    homeRatings: (document.getElementById('homeRatings').value||'').split(',').map(s=>s.trim()).filter(Boolean),
    awayRatings: (document.getElementById('awayRatings').value||'').split(',').map(s=>s.trim()).filter(Boolean),
    homeCoach: f.homeCoach || '',
    awayCoach: f.awayCoach || '',
    status: 'live',
    timestamp: new Date().toISOString(),
    fixtureId: f.id || null
  };
  model.meta.updatedAt = new Date().toISOString();
  refreshUI();
  alert('Live match set in editor. Use Publish to push to GitHub or Export to copy JSON.');
});

/* update live without changing fixture */
document.getElementById('btnUpdateLive').addEventListener('click', ()=>{
  if(!model.live) return alert('No live match set; use Set Live first.');
  model.live.homeScore = Number(document.getElementById('homeScore').value||0);
  model.live.awayScore = Number(document.getElementById('awayScore').value||0);
  model.live.subs = (document.getElementById('liveSubs').value||'').split('\\n').filter(Boolean);
  model.live.homeRatings = (document.getElementById('homeRatings').value||'').split(',').map(s=>s.trim()).filter(Boolean);
  model.live.awayRatings = (document.getElementById('awayRatings').value||'').split(',').map(s=>s.trim()).filter(Boolean);
  model.meta.updatedAt = new Date().toISOString();
  refreshUI();
  alert('Live updated locally.');
});

/* end & archive */
document.getElementById('btnEndAndArchive').addEventListener('click', ()=>{
  if(!model.live) return alert('No live match');
  // add simple homeStats/awayStats placeholders if missing
  if(!model.live.homeStats) model.live.homeStats = [model.live.homeScore||0,0,0,0];
  if(!model.live.awayStats) model.live.awayStats = [model.live.awayScore||0,0,0,0];
  model.archive = model.archive || [];
  model.archive.push(model.live);
  model.live = null;
  model.meta.updatedAt = new Date().toISOString();
  refreshUI();
  alert('Match archived locally. Publish to push to GitHub if you want site to auto-update.');
});

/* export */
document.getElementById('btnExport').addEventListener('click', ()=>{
  const txt = JSON.stringify(model, null, 2);
  navigator.clipboard.writeText(txt).then(()=> alert('JSON copied to clipboard — paste into GitHub data.json or share.'), ()=> {
    // fallback: show in prompt
    prompt('Copy JSON', txt);
  });
});

/* import paste */
document.getElementById('btnImport').addEventListener('click', ()=>{
  const pasted = prompt('Paste JSON here to import (overwrites current editor data).');
  if(!pasted) return;
  try{
    const obj = JSON.parse(pasted);
    model = obj;
    refreshUI();
    alert('Imported.');
  }catch(e){ alert('Invalid JSON'); }
});

/* Publish to GitHub (optional) */
document.getElementById('btnPublish').addEventListener('click', async ()=>{
  // ask for token
  const token = prompt('Enter a GitHub Personal Access Token (repo scope). Leave empty to cancel.');
  if(!token) return;
  const owner = document.getElementById('ghOwner').value.trim();
  const repo = document.getElementById('ghRepo').value.trim();
  const branch = document.getElementById('ghBranch').value.trim() || 'main';
  const path = document.getElementById('filePath').value.trim() || 'data.json';
  if(!owner || !repo) return alert('Enter owner and repo.');

  // fetch current file SHA (if exists)
  const getUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
  let sha = null;
  try{
    const res = await fetch(getUrl + `?ref=${branch}`, { headers: { Authorization: 'token ' + token } });
    if(res.ok){
      const j = await res.json();
      sha = j.sha;
    }
  }catch(e){ console.error(e); }

  const content = JSON.stringify(model, null, 2);
  const body = { message: 'Update data.json via PFL admin', content: b64Encode(content), branch: branch };
  if(sha) body.sha = sha;
  const putRes = await fetch(getUrl, { method: 'PUT', headers: { Authorization: 'token ' + token, 'Content-Type':'application/json' }, body: JSON.stringify(body) });
  if(putRes.ok){
    alert('Published data.json to GitHub ✓');
    // update rawUrl preview
    loadRemote();
  } else {
    const err = await putRes.text();
    alert('Publish failed: ' + err.slice(0,200));
  }
});

/* unlock / simple password */
document.getElementById('btnUnlock').addEventListener('click', ()=>{
  const pw = prompt('Enter admin password');
  const saved = localStorage.getItem('pfl_admin_pw') || 'Rowland12#';
  if(pw === saved){ alert('Unlocked — you can edit now'); } else { alert('Wrong password'); }
});
</script>
</body>
</html>ElementById('awayLogoFile');
  const createMatchBtn = document.getElementById('createMatchBtn');
  const refreshMatches = document.getElementById('refreshMatches');

  let matchesCache = [];
  let editingMatchId = null;

  unlockBtn.addEventListener('click', ()=>{
    if(passInput.value === ADMIN_PASS){
      passInput.value = '';
      adminControls.style.display = 'block';
      alert('Admin unlocked.');
    } else {
      alert('Wrong password.');
    }
  });

  // Create match
  createMatchBtn.addEventListener('click', async ()=>{
    if(!homeName.value.trim() || !awayName.value.trim()){ alert('Enter both team names'); return; }
    createMatchBtn.disabled = true;
    createMatchBtn.textContent = 'Creating...';
    // upload logos if provided
    let homeLogoUrl = '';
    let awayLogoUrl = '';
    if(homeLogoFile.files && homeLogoFile.files[0]){
      homeLogoUrl = await uploadLogoFile(homeLogoFile.files[0], 'team_home');
    }
    if(awayLogoFile.files && awayLogoFile.files[0]){
      awayLogoUrl = await uploadLogoFile(awayLogoFile.files[0], 'team_away');
    }
    const matchObj = {
      home: { name: homeName.value.trim(), coach: homeCoach.value.trim()||'', players: homePlayers.value.split(',').map(s=>s.trim()).filter(Boolean), logoUrl: homeLogoUrl, score: 0 },
      away: { name: awayName.value.trim(), coach: awayCoach.value.trim()||'', players: awayPlayers.value.split(',').map(s=>s.trim()).filter(Boolean), logoUrl: awayLogoUrl, score: 0 },
      status: 'not_started',
      events: []
    };
    try{
      const key = await pushMatch(matchObj);
      alert('Match created.');
      homeName.value=''; awayName.value=''; homeCoach.value=''; awayCoach.value=''; homePlayers.value=''; awayPlayers.value=''; homeLogoFile.value=''; awayLogoFile.value='';
    }catch(e){
      console.error(e); alert('Failed creating match: '+e.message);
    } finally {
      createMatchBtn.disabled = false;
      createMatchBtn.textContent = 'Create Match';
    }
  });

  // Listen matches in real-time and render list
  listenMatches((matches)=>{
    matchesCache = matches || [];
    renderMatchList();
    // If currently editing a match, refresh its editor data
    if(editingMatchId){ refreshEditor(editingMatchId); }
  });

  function renderMatchList(){
    matchList.innerHTML = '';
    if(!matchesCache.length){ matchList.innerHTML = '<div class="muted">No matches yet</div>'; return; }
    // newest first
    matchesCache.sort((a,b)=> (b.createdAt||'').localeCompare(a.createdAt||''));
    matchesCache.forEach(m=>{
      const div = document.createElement('div'); div.className='match-item';
      div.innerHTML = `<div>
          <div style="font-weight:700">${m.home?.name||'Home'} vs ${m.away?.name||'Away'}</div>
          <div class="muted">${m.status || 'not_started'} • ${new Date(m.createdAt||'').toLocaleString()}</div>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button class="small" data-id="${m.id}" data-act="edit">Edit</button>
          <button class="small" data-id="${m.id}" data-act="setLive">Live</button>
          <button class="small" data-id="${m.id}" data-act="end">End</button>
        </div>`;
      matchList.appendChild(div);
    });
    // attach clicks
    matchList.querySelectorAll('button').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        const id = btn.getAttribute('data-id');
        const act = btn.getAttribute('data-act');
        if(act==='edit') openEditor(id);
        else if(act==='setLive') setMatchLive(id);
        else if(act==='end') endMatch(id);
      });
    });
  }

  async function openEditor(id){
    editingMatchId = id;
    matchEditorCard.style.display = 'block';
    document.getElementById('editingTitle').textContent = 'Editing match';
    refreshEditor(id);
  }

  async function refreshEditor(id){
    const m = matchesCache.find(x=>x.id===id);
    if(!m) return;
    document.getElementById('editHomeName').value = m.home?.name || '';
    document.getElementById('editAwayName').value = m.away?.name || '';
    document.getElementById('editHomeScore').value = m.home?.score || 0;
    document.getElementById('editAwayScore').value = m.away?.score || 0;
    // render events
    const el = document.getElementById('evtList');
    el.innerHTML = '';
    (m.events||[]).forEach(ev=>{
      const d = document.createElement('div'); d.style.padding='6px'; d.style.borderBottom='1px solid rgba(255,255,255,0.03)';
      d.innerHTML = `<div style="font-weight:700">${ev.minute} — ${ev.type}</div><div class="muted">${ev.desc}</div>`;
      el.appendChild(d);
    });
    // save button
    document.getElementById('saveMatchBtn').onclick = async ()=>{
      const patch = {
        home: { ...m.home, name: document.getElementById('editHomeName').value.trim(), score: Number(document.getElementById('editHomeScore').value||0) },
        away: { ...m.away, name: document.getElementById('editAwayName').value.trim(), score: Number(document.getElementById('editAwayScore').value||0) }
      };
      await updateMatch(id, patch);
      alert('Saved.');
    };
    document.getElementById('deleteMatchBtn').onclick = async ()=>{
      if(!confirm('Delete match permanently?')) return;
      // remove by setting null
      await updateMatch(id, { deleted: true, status: 'deleted' });
      alert('Marked deleted (it will be hidden).');
    };
    document.getElementById('addEventBtn').onclick = async ()=>{
      const minute = document.getElementById('evtMinute').value.trim() || '';
      const desc = document.getElementById('evtDesc').value.trim();
      const team = document.getElementById('evtTeam').value || '';
      if(!desc){ alert('Add description'); return; }
      const ev = { type: desc.split('-')[0] || 'Event', minute: minute || new Date().getMinutes().toString(), desc, team, timestamp: new Date().toISOString() };
      const newEvents = [ev].concat(m.events || []);
      await updateMatch(id, { events: newEvents });
      document.getElementById('evtMinute').value=''; document.getElementById('evtDesc').value='';
      alert('Event added.');
    };
    document.getElementById('setLiveBtn').onclick = async ()=>{
      // set all matches to not live, then set this one live
      // naive approach: iterate cached matches
      for(const mm of matchesCache){
        await updateMatch(mm.id, { status: mm.id === id ? 'live' : (mm.status === 'deleted' ? 'deleted' : 'finished') });
      }
      alert('Match set to LIVE.');
    };
    document.getElementById('endMatchBtn').onclick = async ()=>{
      await updateMatch(id, { status: 'finished' });
      alert('Match ended.');
    };
  }

  async function setMatchLive(id){
    // same as setLiveBtn but simple
    for(const mm of matchesCache){
      await updateMatch(mm.id, { status: mm.id === id ? 'live' : (mm.status === 'deleted' ? 'deleted' : 'finished') });
    }
    alert('Match set to LIVE.');
  }
  async function endMatch(id){
    await updateMatch(id, { status: 'finished' });
    alert('Match ended.');
  }

  refreshMatches.addEventListener('click', ()=> renderMatchList());

  // convenience: upload logo and replace in match (not in create) - handled in editor if needed via prompt+file
  // (uploadLogoFile is used during create above)
</script>
</body>
  </html>
